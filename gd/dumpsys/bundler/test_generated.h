// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_TEST_H_
#define FLATBUFFERS_GENERATED_TEST_H_

#include "flatbuffers/flatbuffers.h"

namespace bluetooth {
namespace dumpsys {

struct BundleSchemaMap;
struct BundleSchemaMapBuilder;

struct BundleSchema;
struct BundleSchemaBuilder;

struct BundleSchemaMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BundleSchemaMapBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_NAME = 4, VT_DATA = 6 };
  const flatbuffers::String* name() const {
    return GetPointer<const flatbuffers::String*>(VT_NAME);
  }
  const flatbuffers::Vector<uint8_t>* data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t>*>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_NAME) && verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DATA) && verifier.VerifyVector(data()) && verifier.EndTable();
  }
};

struct BundleSchemaMapBuilder {
  typedef BundleSchemaMap Table;
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(BundleSchemaMap::VT_NAME, name);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(BundleSchemaMap::VT_DATA, data);
  }
  explicit BundleSchemaMapBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BundleSchemaMapBuilder& operator=(const BundleSchemaMapBuilder&);
  flatbuffers::Offset<BundleSchemaMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BundleSchemaMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<BundleSchemaMap> CreateBundleSchemaMap(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  BundleSchemaMapBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<BundleSchemaMap> CreateBundleSchemaMapDirect(
    flatbuffers::FlatBufferBuilder& _fbb, const char* name = nullptr, const std::vector<uint8_t>* data = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return CreateBundleSchemaMap(_fbb, name__, data__);
}

struct BundleSchema FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BundleSchemaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_TITLE = 4, VT_ROOT = 6, VT_MAP = 8 };
  const flatbuffers::String* title() const {
    return GetPointer<const flatbuffers::String*>(VT_TITLE);
  }
  const flatbuffers::String* root() const {
    return GetPointer<const flatbuffers::String*>(VT_ROOT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<BundleSchemaMap>>* map() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BundleSchemaMap>>*>(VT_MAP);
  }
  bool Verify(flatbuffers::Verifier& verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_TITLE) && verifier.VerifyString(title()) &&
           VerifyOffset(verifier, VT_ROOT) && verifier.VerifyString(root()) && VerifyOffset(verifier, VT_MAP) &&
           verifier.VerifyVector(map()) && verifier.VerifyVectorOfTables(map()) && verifier.EndTable();
  }
};

struct BundleSchemaBuilder {
  typedef BundleSchema Table;
  flatbuffers::FlatBufferBuilder& fbb_;
  flatbuffers::uoffset_t start_;
  void add_title(flatbuffers::Offset<flatbuffers::String> title) {
    fbb_.AddOffset(BundleSchema::VT_TITLE, title);
  }
  void add_root(flatbuffers::Offset<flatbuffers::String> root) {
    fbb_.AddOffset(BundleSchema::VT_ROOT, root);
  }
  void add_map(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BundleSchemaMap>>> map) {
    fbb_.AddOffset(BundleSchema::VT_MAP, map);
  }
  explicit BundleSchemaBuilder(flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BundleSchemaBuilder& operator=(const BundleSchemaBuilder&);
  flatbuffers::Offset<BundleSchema> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BundleSchema>(end);
    return o;
  }
};

inline flatbuffers::Offset<BundleSchema> CreateBundleSchema(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<flatbuffers::String> title = 0,
    flatbuffers::Offset<flatbuffers::String> root = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BundleSchemaMap>>> map = 0) {
  BundleSchemaBuilder builder_(_fbb);
  builder_.add_map(map);
  builder_.add_root(root);
  builder_.add_title(title);
  return builder_.Finish();
}

inline flatbuffers::Offset<BundleSchema> CreateBundleSchemaDirect(
    flatbuffers::FlatBufferBuilder& _fbb,
    const char* title = nullptr,
    const char* root = nullptr,
    const std::vector<flatbuffers::Offset<BundleSchemaMap>>* map = nullptr) {
  auto title__ = title ? _fbb.CreateString(title) : 0;
  auto root__ = root ? _fbb.CreateString(root) : 0;
  auto map__ = map ? _fbb.CreateVector<flatbuffers::Offset<BundleSchemaMap>>(*map) : 0;
  return CreateBundleSchema(_fbb, title__, root__, map__);
}

inline const BundleSchema* GetBundleSchema(const void* buf) {
  return flatbuffers::GetRoot<BundleSchema>(buf);
}

inline const BundleSchema* GetSizePrefixedBundleSchema(const void* buf) {
  return flatbuffers::GetSizePrefixedRoot<BundleSchema>(buf);
}

inline bool VerifyBundleSchemaBuffer(flatbuffers::Verifier& verifier) {
  return verifier.VerifyBuffer<BundleSchema>(nullptr);
}

inline bool VerifySizePrefixedBundleSchemaBuffer(flatbuffers::Verifier& verifier) {
  return verifier.VerifySizePrefixedBuffer<BundleSchema>(nullptr);
}

inline const char* BundleSchemaExtension() {
  return "bfbs";
}

inline void FinishBundleSchemaBuffer(flatbuffers::FlatBufferBuilder& fbb, flatbuffers::Offset<BundleSchema> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedBundleSchemaBuffer(
    flatbuffers::FlatBufferBuilder& fbb, flatbuffers::Offset<BundleSchema> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace dumpsys
}  // namespace bluetooth

#endif  // FLATBUFFERS_GENERATED_TEST_H_
